# Blackout

Blackout is an API load testing infrastructure for SaaS platforms.  We
have ambitions to make some of the facilities of this available as a
file-driven DSL so it's easy to build and customize test
infrastructure without having to write a bunch of custom code.

This library is intended to be used both as a local test runner or
eventually a master node for distributed testing.

Simulated load tests and reports are generated by
[clj-gatling](https://github.com/mhjort/clj-gatling).

To observe system behavior under test, possibly customized to the
application in question, we leverage [Reimann](http://riemann.io/), a
high performance stream-oriented statistics aggregator and it's
dashboard application [Riemann Dashboard](http://riemann.io/dashboard.html).

The use of Reimann for real-time charting and reporting is optional,
allowing blackout to be used as a standlone test platform against a
co-located server, such as in automated build and test.

## Theory of Operation

Blackout is driven by 'simulations', a sequence of operations that
define a single user's interaction with the system under test.

    (def ping-simulation
      {:name "Ping simulation"
       :scenarios [{:name "Ping scenario"
                    :steps [{:name "Authenticate"
                             :request #'authenticate}
                            {:name "Ping Status Endpoint"
    ;                        :sleep-before (constantly 1000)
                             :request #'ping}]}]})

This simulation will cause an authentication request followed by
a ping request to happen back to back until the number of total
requested simulations has been reached.  The simulation steps are
implemented by the #'authenticate and #'ping functions. e.g.

    (defn ping
      [context]
      (success-chan? (request :get "/v1/user/" {:context context})))

We use the [http-kit](http://www.http-kit.org/client.html)
non-blocking IO HTTP client library to enable thousands of concurrent
requests to be generated per node without being limited by JVM
threads.  Each request returns a core.async channel that represents a
response 'promise'.  success-chan?  transforms this into a true/false
response based on the HTTP response code.

The simulation runner will register to respond to the result when
available without blocking a thread and account for OK vs. KO outcomes
based on the true/false status returned. 

The [clj-gatling](https://github.com/mhjort/clj-gatling) docs have
more information about how to structure simulation steps.


## Block Diagram

Single node testing

System Under Test <-> Test Runner -> Report -> Reimann Server -> Reimann Dashboard

Cluster-based testing

Cluster Under Test <-> Test Runner(s) -> Dist Reports -> Reimann Server -> Reimann Dash

## Pre-requisites for local testing

Blackout can be run from the command line via `lein run` or
interactively via `lein repl`.  At the command line, the arguments to
run are `<namespace> <simulation> <num_users> <request_count>`.  The
provide namespace should be on the JVM classpath, contain a variable
`simulations` such as `blackout.sb/simulations` that contains a map of
configured simulations to be indexed by the simulation argument.

The number of users dictates the number of concurrent simulation
agents and the number of requests is approximately how many
back-to-back requests all the simulations together will execute

When using Mac OS X, issue the following commands at the terminal: 

1. Install Riemann and associated tools
    1. `brew install riemann`
    2. `sudo gem install riemann-client riemann-tools riemann-dash`

2. Run Riemann and Riemann Dash
    1. `riemann ./src/riemann.config` 
    2. `sudo riemann-dash ./src/config.json` (sudo is necessary to permit writes for config saves)
    3. Open your web browser to http://localhost:4567 to see Riemann real-time stats

3. Run Blackout
    1. Run a blackout simulation `lein run blackout.sb ping 5 100`
    2. After, open report file, e.g. `open /tmp/20161215220318568/index.html`

## Pre-requisites for remote testing

1. Install Riemann on a test server

2. SSH with '-L 5556:localhost:5556' and run 'riemann'

3. SSH with '-L 4567:localhost:4567' and run 'sudo riemann-dash'

4. Install [leiningen](http://leiningen.org/)

4. cd /var/lib/blackout; lein repl

5. (do (require 'blackout.core) (in-ns 'blackout.core))

6. (run blackout.sb/simulations :login 10 2 {:context {:username "eslick" :password "password"}})


## Roadmap


### Development

- How to make load testing more generic with external simulation files?
- Standard way to configure credentials via context with external sources
- Use clojurecast to allow distributed test generators to coordinate, e.g. unique name generation.
- Use spec.test and/or simulant to generate test cases against specific APIs

### Support

- Ansible script for configuring a test node to run riemann, riemann-dash, blackout from a JAR and connect to upstream Reimann server
- Ansible script for creating a cluster of test nodes
- Parse a simple DSL for trivial testing based on a file located on
  the classpath, e.g. using CURL styel commands for individual steps
  with a simple variable substition model

## Copyright and License

Copyright Â© 2016 Vital Labs, Inc.

Released under the MIT License

